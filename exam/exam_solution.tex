\documentclass[a4paper]{article}
\usepackage[margin=0.5cm,includeheadfoot,asymmetric]{geometry}
\usepackage[utf8]{inputenc} % Required for inputting international characters
\usepackage{hyperref}
\hypersetup{
    colorlinks=true, %set true if you want colored links
    linktoc=all,     %set to all if you want both sections and subsections linked
    linkcolor=blue,  %choose some color if you want links to stand out
}
\usepackage{titlesec}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\fancyhf{}
\rhead{Jan Piroutek - \textit{jpir@itu.dk}}
\chead{Exam solution}
\rfoot{\thepage\ of \pageref{LastPage}}
\renewcommand{\headrulewidth}{1.0pt}
\renewcommand{\footrulewidth}{1.0pt}
\pagestyle{fancy}

\newcommand\sectionS[1]{%
  \section*{#1}%
  \addcontentsline{toc}{section}{#1}}
\newcommand\subsectionS[1]{%
  \subsection*{#1}%
  \addcontentsline{toc}{subsection}{#1}}

\titleformat{\section}[block]{\Large\bfseries\filcenter}{}{1em}{}
\titleformat{\subsection}[hang]{\bfseries}{}{1em}{}

\begin{document}
\pagestyle{fancy}

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\begin{titlepage} % Suppresses displaying the page number on the title page and the subsequent page counts as page 1
	\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for horizontal lines, change thickness here

	\center % Centre everything on the page
	
	%------------------------------------------------
	%	Headings
	%------------------------------------------------
	
	\textsc{\LARGE IT University of Copenhagen}\\[1.5cm] % Main heading such as the name of your university/college
	
	\textsc{\Large Operating systems and C - BSOPSYC1KU}\\[0.5cm] % Major heading such as course name
	
	%------------------------------------------------
	%	Title
	%------------------------------------------------
	
	\HRule\\[0.4cm]
	
	{\huge\bfseries Solution for exam, category SWU fall 2022}\\[0.4cm] % Title of your document
	
	\HRule\\[1.5cm]
	
	%------------------------------------------------
	%	Author(s)
	%------------------------------------------------
	
	% If you don't want a supervisor, uncomment the two lines below and comment the code above
	{\large\textit{Author}}\\
	Jan \textsc{Piroutek} % Your name

    {\large\textit{Email}}\\
	jpir@itu.dk

	
	%------------------------------------------------
	%	Date
	%------------------------------------------------
	
	\vfill\vfill\vfill % Position the date 3/4 down the remaining page
	
	{\large\today} % Date, change the \today to a set date if you want to be precise
	
	%------------------------------------------------
	%	Logo
	%------------------------------------------------
	
	%\vfill\vfill
	%\includegraphics[width=0.2\textwidth]{placeholder.jpg}\\[1cm] % Include a department/university logo - this will require the graphicx package
	 
	%----------------------------------------------------------------------------------------
	
	\vfill % Push the date up 1/4 of the remaining page
	
\end{titlepage}

\tableofcontents

\vspace{2cm}

\newpage

\sectionS{Question 1 - Data lab}
\subsectionS{A. Describe your implementation of \textit{howManyBits(x)}}
The easiest solution for this would be create mask, that isolates each bit of the number,
then take that bit and use the \textit{!} twice (\textit{!!}. Single \textit{!} gives 
1 if the number is only full of zeros, which would be if the bit, for which the mask was created
was set to 0. So for counting them I need to negate the value again, so I would get 
0 in this case and 1 otherwise. Then I can just sum those numbers together with \textit{+}
operator. \\
This solution is easy, but takes a lot of operations, so I needed to be smarter. \\
Let's start from broader perspective. If I want to represent the number in the twos complement
I'll always need one bit to basically say if the number is positive or negative (MSB). 
And what with the rest of the number. \\
Now lets think little bit more how twos complement works. If I have some number represented in
twos complement, then first bit of the number is giving the value we need to subtract
from the value stored in the next $x-1$ bits. Lets say I have two numbers $x$ and its absolute
value $y = |x|$. If $x$ is positive, then $y = x$ and for representing $x$ as twos complement.
I just need as much bits as is the highest position of bit set to one (e.g. $x = 7 = 0b111$ I need
3 bits), plus 1 as the leading 0 for MSB. \\
Lets think about case when $x$ is negative. Then I know the MSB is set to one, and the rest
of the number tells me, how much I have to subtract from $2^{position\_of\_MSB}$. Neat thing 
about twos complement is this thing tho, if I have some negative value $x$, the positive value
of $-x$ is also representable as twos complement, except for $0b10000\cdots$, where there are only
zeros after MSB one. What if I just add one to the negative number? \\
I will state this $\rightarrow$ if I increment negative number of twos complement by one, it will still
need same amount of bits for representation as the old one. 
\begin{itemize}
  \item{$-8 + 1 = -7$ and $-8 = 0b1000$; $-7 = 0b1001$}
  \item{$-3 + 1 = -2$ and $-3 = 0b101$; $-2 = 0b110$} 
  \item{$-1 + 1 = 0$ and $-1 = 0b1$; $ 0 = 0b0$}
\end{itemize}

\noindent This way I can just get the value of $x + 1$ and compute how many bits I need for the absolute
value $|x + 1|$ (x is still negative). How to easily get this value? Twos complement
is really nice to me. If I want value of $-x$ all I need to negate all bits and add 1.
But what I want is $(~x + 1) - 1 = ~x$. \\

\noindent So now I just need to get the absolute value of $x$ and compute the position of first bit, that
is set to one. Lets split it this into two parts. \\

\noindent{\large{Getting absolute value}} \\

\noindent First I need to know if the number is negative or positive. If $x$ is positive I want to 
get $x$, otherwise I want to get $~x$. First I isolate MSB with mask of $0x80 << 0x18$ (minimal number
explained more in next subquestion). Then I can reuse code of conditional function (one of the other
tasks). Conditional would be if $x$ after mask is 0 or not. If it is 0, the $x$ was positive, negative
otherwise. Then I can flip the condition, negate it and add 1. This way I will either get integer
consisting of all ones or all zeros. In the end I just use this condition as mask for $x$ or $~x$ 
and pick the desired one. One of them will be turned to all zeros, other will remain the same.
So I can just use $|$ to get $x$ I want. Now I have aquired the requested value. \\
 
\noindent{\large{Computing number of bits}} \\

\noindent Now when I have the positive value all I need to do is to get position of first 1. 
First a copy the first bit to the right of it, in $\log_{2}(32)$ steps. Starting from one
I shift all bits to the right by one and take $x | (x >> 0x01)$. This copies the most left one
to the next bit. Then I do the same but with $0x02$, that copies the leftest one and its copy from
last step to the next two bits. Then with $0x04$ and so on. \\
\noindent know I have copied the leftest one and I need to count how many bits I have in number.
This either can be slow or I can use divide and conquer technique. Each bit has information how
many ones are in him (one if set to one, zero if set to zero). Now what I do is to align bits, that
I want to add and use mask to separete odd and even bits. In other words I move even bits under
odd bits and add them together. Now I know how many bits are in the two consecutive bits. Then
I do the same for the pairs of bits. Align (shift by two this time) and mask them (I need
a different mask. First mask needed to mask even bits $\rightarrow 0b0101010101\cdots = 0x55555555$,
this needs to mask even pairs $\rightarrow 0b00110011\cdots = 0x33333333$.
Next for the pairs of four bits, 8bits and in the end 16bits. But because I didn't wanted to use
more mask than necessary, my code could have left some bits set in first part of the number. 
So I needed to mask the remaining bits, so it wouldn't return bigger numbers than $32$ (maximal
amount of ones in integer).
\\

\noindent In the end only thing I need is to add the 1 bit, that I have not acounted for earlier 
(the MSB of twos complement, saying if it is negative or positive)  \\

\newpage

\begin{lstlisting}
int howManyBits(int x) {
  int min = 0x80 << 0x18;
  int fives = 0x55 + (0x55 << 0x08) + (0x55 << 0x10) + (0x55 << 0x18);
  int threes = 0x33 + (0x33 << 0x08) + (0x33 << 0x10) + (0x33 << 0x18);
  int of = 0x0F + (0x0F << 0x08) + (0x0F << 0x10) + (0x0F << 0x18);
  int max_num = 0x3F;
  int cond;
  int neg_cond;
  int count;

  // if is x negative change it to its positive value
  // otherwise keep original positive value
  // 0x80000000 can stay the same, because it still needs all of bits used
  // izolate first bit
  cond = x & min;
  // from previous task
  neg_cond = !!cond;
  cond = ~(neg_cond) + 1;
  // why ~x and not ~x + 1
  // I know that in every twos complement I need one bit for basically the sign
  // not adding one when negating the number won't change it's size, if I remmember to
  // add that one bit back to result
  x = ((~x) & cond) | (x & ~cond);

  //copy the first 1 bit to the right
  x = x | (x >> 0x01);
  x = x | (x >> 0x02);
  x = x | (x >> 0x04);
  x = x | (x >> 0x08);
  x = x | (x >> 0x10);


  // count the number of 1s in x
  // this was taken from book Hacket's delight (I believe it's called)
  // Don't know if you can count it as solved but I don't know any other way
  // This is based on divide and conquer
  // each bits knows how many 1's are in it (either 1 or 0)
  // them you compute how many bits set have two next door bits
  // them 4, 8 and so on
  count = x + (~((x >> 0x01) & fives) + 1);
  count = (count & threes) + ((count >> 0x02) & threes);
  count = (count + (count >> 0x04)) & of;
  count = count + (count >> 0x08);
  count = count + (count >> 0x10);
  count = count & max_num;
  // don't forget to add 1
  return count + 1;
}
\end{lstlisting}


\subsectionS{B. Describe your implementation of \textit{tmin(void)}}
From definition of twos complement. the minimal number is composed of bits, where 
each bit is set to one. \\
The function should return minimal integer, so that means I need 32 bits, all set to one.
Largest number I can use, which has all bits set is $0x80$ ($-128$). Then I can use the
left shift ($<<$) operator in C, which moves bits to the left, direction to highest bit, and 
copies their value to the old place. So if I do $0x80 << 0x01$, shift 8 bits set to one to the
left by one place, I get 9 bits all set to one, if it doesn't overflow. Integer has 32 bit, so
to get them all set to one I just need to shift $0x80$ by $0x18$ (24) places. This gives me
integer with all bits set to one -> smallest number, that fits into integer.

\begin{lstlisting}
int tmin(void) {
  return 0x80 << 0x18;
}
\end{lstlisting}

\newpage
\sectionS{Question 2 - Attack lab}
\subsectionS{A. What happens when the c3 (ret)
assembly instruction is executed? Does
anything in the stack change? }

Just shortly stack is a virtual memory data structure, that holds data for called functions.
Whenever procedure is called, the return address is pushed to the top of the stack and then
it allocates memory for that procedure (like variables and procedure parameters). Next to stack
there is a register called stack pointer. That is an address on stack, where the current running
programm is. \\
When the c3 ret is called, there should be return address present on the stack. The programs 
stack pointer points on to the point in memory where return address is. Ret pops the address
out of the stack and stores it into instruction pointer register. Poping something 
from the stack is equivalent of incrementing of the stack pointer. The return address is location
of next programm instruction, that should be executed after finishing the procedure. After the pop
the return address and other procedure parameters won't be on stack anymore $\rightarrow$
the stack memory of that function will be deallocated.
\subsectionS{B. What is a gadget farm? Describe an
example of how you use one in your
code.}



\newpage
\sectionS{Question 3 - Malloc lab}
\subsectionS{A. Explain in detail your implementation of the \texttt{mm\_malloc} function.}
Lets start from heap structure. Heap consists of blocks. Each block has a header and footer.
Header and footer are both 1 \textit{WORD} long and contains information about size of the block and
information, if the block is allocated or free in format $(size | 0x01)$ for allocated blocks
and $(size | 0x0)$ for free blocks. If the block is free between header and footer, there is
information about previous and next free block. The information is address of the block.
Each address is 1 \textit{WORD} long, so the minimal length of block is 4 \textit{WORD}s. 
Thanks to header 
and footer I can traverse though blocks like throufh doubly linked linked list. Information
about previous and next free blocks creates an explicit free list. This list can be used to 
search faster for free space, when allocating memory. \\
Now get to memory allocation. First I ignore any request for memory of size 0 or smaller, those
requests don't make any sense. Then I need to align block. The block should be aligned so
their size is divisible by \textit{DWORD} (double \textit{WORD}). 
If size is smaller than \textit{DWORD} it should take space of at least 4 \textit{WORD}s, so  
in case this memory is freed later, I can put this space into explicit free list, where I need
2 \textit{WORD}s for pointers to other free blocks and two more for header and footer. 
If it is not smaller I just need to align it to be divisible by \textit{DWORD}. \\
After alignment I have size of block I really need to allocate, including header and footer.
Then I can go through free list. I start from first free block in the list, check its size and
if it is enough I return the block, otherwise I take pointer to next free block, from the body
of current free block and continue on him, until I find fitting block or I end up on the end of 
the list. If no block was sufficient I return \textit{NULL}. \\
{\large Case 1: I have found free block}\\
\\
Now I have enough space to allocate. Now I need to do two things. First I have to check, if the
block isn't too big, so I don't waste any space. If the size that would be unused, could be 
its own free block (is at least 4 \textit{WORD}s long), I set up header and footer of newly allocated
block. In other words I put information about size and allocation to the header and footer.
Then I delete this block from free list. Then I go to the end of footer of this block. I create
new header and footer with information about this block, like size and the fact, that it's free.
In the end I add this block to the beginnig of the free list. Otherwise I don't split anything
and just update header and footer information, that the block is allocated and remove it from
free list. \\
Now the block is allocted and I can return the pointer. \\

\noindent{\large Case 2: Finding free block returned \textit{NULL}}\\
If no block is found I need to extend the heap. I either extend by heap by some constant or
,if requested size is even bigger, by the requested size. Basically I just align the 
number of \textit{WORD}s I need to allocate, to be even and then I call \textit{mem\_sbrk}
to get that amount of memory, after that I just put information about size (and that the block
is free) to the header and footer of returned memory. In the end I try to coalesce the memory.
Because this block was added to the end of the heap, only two coalescing cases can happen, out
of 4 described in the book. Either the block of memory at the end of heap before extension
was free, then I join these two blocks, remove end block of heap before extension from free
list and add newly created block to the free list. Or the other case, the last block 
was full, so I just add this new block to the free list and no joining is happening.
\\ 
After this I have free block big enough to contain requested memory, so I do same process as
described before, about placing information to the header and potencial splitting of new block.

\subsectionS{B. What is pointer arithmetic? Describe how you use it in your version of mm.c}

When using arithmetic operations on pointers in C, the value of result scales based on 
type of the pointer. For example, let me have an array of integer and a pointer to the beginning
of the array $int *x$. Just to have it easy let starting address of  an array be equal to zero
$int* x = 0$. Normaly if I used arithmetic operation like $x++$, the result would be $1$. 
But because $x$ is a pointer to some integer, which has size of \textit{4 bytes}, it will
return result scaled to the size of integer $x++ == x + sizeof(int) == 4$, which is address of
next integer in array. \\
For any type the expresion $pointer_to_type_t + x$ will be expanded to 
$pointer_to_type + (x * sizeof(type_t))$. \\

\noindent{\large Use of pointer arithmetic in mm.c}
Not sure if in my case was this the use or more of a problem I needed to avoid (maybe both).
When moving through list of blocks I needed to look into header. I had pointer to the beginning
of the block, but header was one \textit{WORD} behind. So I needed to change type of pointer to
char ($sizeof(char) = 1B$, so I could change the address by exactly one \textit{WORD} and not by
$WORD * sizeof(typeOfPointer)$. This also applies for going to next/previous blocks in the list, 
when I need to compute the next pointer from size allocated in the header and don't want to
multiply it by data type. Other important use is in explicit free list I have, when I need
the address of the next or previous free block, same thing applies as for header and footer
of normal block.

\newpage

\begin{lstlisting}
/* rounds up to the nearest multiple of ALIGNMENT */
#define ALIGN(size) (((size) + (ALIGNMENT-1)) & ~0x7)

#define SIZE_T_SIZE (ALIGN(sizeof(size_t)))

/* Basic constants and macros */
#define WSIZE 4
/* Word and header/footer size (bytes) */
#define DSIZE 8
/* Double word size (bytes) */
#define CHUNKSIZE (1<<12) /* Extend heap by this amount (bytes) */

#define MAX(x, y) ((x) > (y)? (x) : (y))

/* Pack a size and allocated bit into a word */
#define PACK(size, alloc) ((size) | (alloc))

/* Read and write a word at address p */
#define GET(p) (*(unsigned int *)(p))
#define PUT(p, val) (*(unsigned int *)(p) = (val))

/* Read the size and allocated fields from address p */
#define GET_SIZE(p) (GET(p) & ~0x07)
#define GET_ALLOC(p) (GET(p) & 0x1)

/* Given block ptr bp, compute address of its header and footer */
#define HDRP(bp) ((char *)(bp) - WSIZE)
#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)

/* Given block ptr bp, compute address of next and previous blocks */
#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)))
#define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE((char *)(bp) - DSIZE))

// jumping through free list
#define NEXT_FREE_PTR(bp) (*(char **)(bp + WSIZE))
#define PREV_FREE_PTR(bp) (*(char **)(bp))

static void* find_fit(size_t size);
static void place(void* bp, size_t size);
static void* coalesce(void *bp);
static void* extend_heap(size_t words);

// pointer to start of heap list
static void* heap_listp = 0;

// pointer to explicit free list
static void* exp_free_listp = 0;

static void add_to_free_list(void* bp);
static void delete_from_free_list(void * bp);

/*
 * mm_init - initialize the malloc package.
 */
int mm_init(void)
{
	/* Create the initial empty heap */
	// 8 * WSIZE because in explicit free list I need more space for pointers to prev and next free blocks
	// implicit list is enough with 4 * WSIZE
	if ((heap_listp = mem_sbrk(8*WSIZE)) == (void *)-1)
		return -1;
	PUT(heap_listp, 0);
	/* Alignment padding */
	PUT(heap_listp + (1*WSIZE), PACK(DSIZE, 1)); /* Prologue header */
	PUT(heap_listp + (2*WSIZE), PACK(DSIZE, 1)); /* Prologue footer */
	PUT(heap_listp + (3*WSIZE), PACK(0, 1));
	/* Epilogue header */
	heap_listp += (2*WSIZE);

	// pointer to explicit free list
	exp_free_listp = heap_listp;
	
	/* Extend the empty heap with a free block of CHUNKSIZE bytes */
	if (extend_heap(CHUNKSIZE/WSIZE) == NULL)
		return -1;

	
	return 0;
}

/*
 * mm_malloc - Allocate a block by incrementing the brk pointer.
 *     Always allocate a block whose size is a multiple of the alignment.
 */
void *mm_malloc(size_t size)
{
	size_t asize;
	/* Adjusted block size */
	size_t extendsize; /* Amount to extend heap if no fit */
	void *bp;

	/* Ignore spurious requests */
	if (size == 0)
		return NULL;
	/* Adjust block size to include overhead and alignment reqs. */
	if (size <= DSIZE)
		asize = 2*DSIZE;
	else
		asize =  (DSIZE) * ((size + (DSIZE) + (DSIZE-1)) / DSIZE);

	/* Search the free list for a fit */
	if ((bp = find_fit(asize)) != NULL) {
		place(bp, asize);
		return bp;
	}

	/* No fit found. Get more memory and place the block */
	extendsize = MAX(asize,CHUNKSIZE);
	if ((bp = extend_heap(extendsize/WSIZE)) == NULL)
		return NULL;

	place(bp, asize);

	return (void *)bp;
}

// find place for memory of size 'size'
static void* find_fit(size_t size) {
	// first fit algorithm for implicit free list
	void *bp;
	//printf("ptr %x", bp);
	for (bp = exp_free_listp; GET_ALLOC(HDRP(bp)) == 0; bp = NEXT_FREE_PTR(bp)) {
		//printf("ptr %x", bp);
		if (size <= GET_SIZE(HDRP(bp))) {
			return bp;
		}
	}
	//printf("ptr %x", bp);
	return NULL;
}

// set header and footer of newly allocated block
static void place(void* bp, size_t size) {
	// get size of while block
	size_t csize = GET_SIZE(HDRP(bp));

	// if the size of block is bigger than requested size
	// and after allocation there will still be enough space for header and footer (and payload)
	// split the block
	if ((csize - size) >= (2*DSIZE)) {
		// put info to block header that blocks size is 'size' and 1 for allocated
		// same for footer
		PUT(HDRP(bp), PACK(size, 1));
		PUT(FTRP(bp), PACK(size, 1));
		delete_from_free_list(bp);
		// move pointer to end of needed space for allocation
		bp = NEXT_BLKP(bp);
		// here the block splits
		// put info to start of new block about its size (csize - size) and info that it's free 0
		PUT(HDRP(bp), PACK(csize-size, 0));
		PUT(FTRP(bp), PACK(csize-size, 0));
		//add_to_free_list(bp);
		coalesce(bp);
	} else {
		// just allocate whole block
		PUT(HDRP(bp), PACK(csize, 1));
		PUT(FTRP(bp), PACK(csize, 1));
		delete_from_free_list(bp);
	}
}

// merge free block with its surroundings
static void *coalesce(void *bp)
{
	//printf("ptr %x\n", bp);
	// is previous block allocated or is bp the first block in the heap
	size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp))) || PREV_BLKP(bp) == bp;
	// is next block allocated
	size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));
	// size of current block
	size_t size = GET_SIZE(HDRP(bp));

	// 4 cases for surrounding blocks
	if (prev_alloc && next_alloc) {
		/* Case 1 */
		// everything around block is allocated
		// can't be merged with anything
		add_to_free_list(bp);
		return bp;
	}
	else if (prev_alloc && !next_alloc) {
		/* Case 2 */
		// previous block is allocated and next block is free
		// merge this block with next block
		
		
		// increase total size with size of next block
		size += GET_SIZE(HDRP(NEXT_BLKP(bp)));
		// delete next block from free list so I can add merged block later
		delete_from_free_list(NEXT_BLKP(bp));

		// put info to blocks header about new size and that it's free
		// also into footer
		PUT(HDRP(bp), PACK(size, 0));
		PUT(FTRP(bp), PACK(size, 0));
	}
	else if (!prev_alloc && next_alloc) {
		/* Case 3 */
		// previous block is free, but next block is allocated
		// merge this block with previous block
		
		// increase total size with size of previous block
		size += GET_SIZE(HDRP(PREV_BLKP(bp)));
		// delete previous block from free list so I can add merged block later
		delete_from_free_list(PREV_BLKP(bp));

		// put info to footer of this block about size and free 0
		PUT(FTRP(bp), PACK(size, 0));
		// put info to header of previous block
		PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));
		// set pointer to previous block
		bp = PREV_BLKP(bp);
	}
	else {
		/* Case 4 */
		// both previous and next block are free
		// have to merge them all together
		
		// total size is sum of size of this block + previous block + next block
		size += GET_SIZE(HDRP(PREV_BLKP(bp))) +
			GET_SIZE(FTRP(NEXT_BLKP(bp)));

		// delete both previous and next block from free list so merged can be added later
		delete_from_free_list(PREV_BLKP(bp));
		delete_from_free_list(NEXT_BLKP(bp));
		// put info about size and free to header of previous block
		PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));
		// put info about size and free to footer of next block
		PUT(FTRP(NEXT_BLKP(bp)), PACK(size, 0));
		// set pointer to previous block
		bp = PREV_BLKP(bp);
	}
	// add merged block
	add_to_free_list(bp);
	return bp;
}

// extending heap
static void *extend_heap(size_t words)
{
	void *bp;
	size_t size;

	/* Allocate an even number of words to maintain alignment */
	size = (words % 2) ? (words+1) * WSIZE : words * WSIZE;
	if ((long)(bp = mem_sbrk(size)) == -1)
		return NULL;

	// Initialize free block header/footer and the epilogue header
	PUT(HDRP(bp), PACK(size, 0));
	PUT(FTRP(bp), PACK(size, 0));
	// last block is of size 0
	PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1));
	// merge if last block was free
	return coalesce(bp);
}

// put bp to beginning of the free list
static void add_to_free_list(void* bp) {
	NEXT_FREE_PTR(bp) = exp_free_listp;
	PREV_FREE_PTR(exp_free_listp) = bp;
	PREV_FREE_PTR(bp) = NULL;
	exp_free_listp = bp;
}

// delete block from free list
static void delete_from_free_list(void * bp) {
	if (PREV_FREE_PTR(bp) == NULL) {
		// bp points to beginnig of free list
		exp_free_listp = NEXT_FREE_PTR(bp);
	} else {
		//void *p = PREV_FREE_PTR(bp);
		//void *n = NEXT_FREE_PTR(bp);
		NEXT_FREE_PTR(PREV_FREE_PTR(bp)) = NEXT_FREE_PTR(bp);
	}
	PREV_FREE_PTR(NEXT_FREE_PTR(bp)) = PREV_FREE_PTR(bp);
}
\end{lstlisting}

\newpage
\sectionS{Question 4 - Topics from the class}
\subsectionS{A. What is the difference between traps, faults 
and aborts in the context of interrupts?}
\subsectionS{B. What is the difference between an ephemeral 
and a well-known port? Give examples of
when either is used.} 
\subsectionS{C. What is a memory leak? When does it occur? 
What can you do to avoid it?} 
\subsectionS{D. What is a race-condition? Why is a race-condition hard 
to debug? Which instructions can
you use to avoid race-conditions? 
Why are these instructions expensive?} 


%----------------------------------------------------------------------------------------
\end{document}

